#include <EASTL/string.h>
#include <stdlib.h>

#ifndef __STRING_INC__
#define __STRING_INC__

namespace std {
    //using eastl::char_traits;
    using eastl::basic_string;
    using eastl::string;
    using eastl::wstring;
    //using eastl::stoi;
    //using eastl::stol;
    //using eastl::stoll;
    //using eastl::stoul;
    //using eastl::stoull;
    inline float stof ( const eastl::string& str, ::size_t* pos = nullptr ) {
        char* ptr;
        float ret = ::strtof(str.c_str(), &ptr);
        if (pos != nullptr) {
            *pos = ptr-str.c_str();
        }
        return ret;
    }
    inline float stof ( const eastl::wstring& str, ::size_t* pos = nullptr ) {
        wchar_t* ptr;
        float ret = ::wcstof(str.c_str(), &ptr);
        if (pos != nullptr) {
            *pos = ptr-str.c_str();
        }
        return ret;
    }
    inline double stod ( const eastl::string& str, ::size_t* pos = nullptr ) {
        char* ptr;
        double ret = ::strtod(str.c_str(), &ptr);
        if (pos != nullptr) {
            *pos = ptr-str.c_str();
        }
        return ret;
    }
    inline double stod ( const eastl::wstring& str, ::size_t* pos = nullptr ) {
        wchar_t* ptr;
        double ret = ::wcstod(str.c_str(), &ptr);
        if (pos != nullptr) {
            *pos = ptr-str.c_str();
        }
        return ret;
    }
    inline long double stold( const eastl::string& str, ::size_t* pos = nullptr ) {
        char* ptr;
        long double ret = ::strtold(str.c_str(), &ptr);
        if (pos != nullptr) {
            *pos = ptr-str.c_str();
        }
        return ret;
    }
    inline long double stold( const eastl::wstring& str, ::size_t* pos = nullptr ) {
        wchar_t* ptr;
        long double ret = ::wcstold(str.c_str(), &ptr);
        if (pos != nullptr) {
            *pos = ptr-str.c_str();
        }
        return ret;
    }
    
    using eastl::to_string;
    using eastl::to_wstring;
    
    template <class charT> class basic_ostringstream;
    template <class CharT>
    basic_ostringstream<CharT>&
    operator<<(basic_ostringstream<CharT>& os,
               const basic_string<CharT>& str) {
        for (auto it = str.begin(); it != str.end(); it++) {
            os.put(*it);
        }
        return os;
    }
    
    template <class charT> class basic_istringstream;
    template <class CharT>
    basic_istringstream<CharT>& getline(basic_istringstream<CharT>& input,
                                        basic_string<CharT>& str,
                                        CharT delim) {
        return input.getline(str, delim);
    }
    
    template <class charT> class basic_fstream;
    template <class CharT>
    basic_fstream<CharT>& getline(basic_fstream<CharT>& input,
                                  basic_string<CharT>& str,
                                  CharT delim='\n') {
        str.erase();
        for (size_t i = 0; i < str.max_size() && !input.eof(); i++) {
            CharT c = input.get();
            if (c == delim) {
                break;
            }
            str.push_back(c);
        }
        return input;
    }
}

#endif // __STRING_INC__

