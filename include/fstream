#include <stdio.h>
#include <ios>
#include <EASTL/algorithm.h>

#pragma once

namespace std {
    template <class charT>
    class basic_fstream : public ios {
    public:
        basic_fstream() : f(NULL), fmt("%") { }
        basic_fstream(const char* s) : f(NULL), fmt("%") {
            open(s);
        }
        basic_fstream(const char* s, ios::openmode mode) : f(NULL), fmt("%") {
            open(s, mode);
        }
        virtual ~basic_fstream() {
            if (is_open()) {
                close();
            }
        }
        virtual void open(const char* s, ios::openmode mode) {
            _open(s, mode);
        };
        virtual void open(const char* s) {
            open(s, ios::binary);
        }
        virtual void open(const eastl::string s) {
            open(s.c_str(), ios::binary);
        }
        virtual void open(const eastl::string s, ios::openmode mode) {
            open(s.c_str(), mode);
        }
        virtual void _open(const char* s, ios::openmode mode) {
            char smode[4] = {0};
            if (mode&ios::app) {
                smode[0] = 'a';
                if (mode&ios::in) {
                    smode[1] = '+';
                }
            }
            else if (mode&ios::out) {
                smode[0] = 'w';
                if (mode&ios::in) {
                    smode[1] = '+';
                    if (!(mode&ios::trunc)) {
                        smode[0] = 'r';
                    }
                }
            }
            else if (mode&ios::in) {
                smode[0] = 'r';
            }
            if (mode&ios::binary) {
                if (smode[0] == '\0') {
                    smode[0] = 'b';
                }
                else if (smode[1] == '\0') {
                    smode[1] = 'b';
                }
                else if (smode[2] == '\0') {
                    smode[2] = 'b';
                }
            }
            f = fopen(s, smode);
            if (mode&ios::ate) {
                fseek(f, 0, SEEK_END);
            }
        }
        bool is_open() const {
            return f != NULL;
        }
        void close() {
            fclose(f);
            f = NULL;
        }
        long tellg() {
            return ftell(f);
        }
        bool good() {
            return is_open() && ferror(f) == 0;
        }
        bool fail() {
            return !good();
        }
        bool operator!() {
            return fail();
        }
        bool bad() {
            return !good();
        }
        bool eof() {
            return feof(f);
        }
        void clear() {
            clearerr(f);
        }
        void setstate(iostate state) {
            if (state & ios::goodbit) {
                clear();
            }
            if (state & ios::badbit) {
                abort();
            }
            if (state & ios::failbit) {
                abort();
            }
            if (state & ios::eofbit) {
                fseek(f, 0, SEEK_END);
            }
        }
        void unget() {
            fseek(f, -1, SEEK_CUR);
        }
        charT peek() {
            charT c = get();
            unget();
            return c;
        }
        charT get() {
            charT c;
            fread(&c, sizeof(charT), 1, f);
            return c;
        }
        void put(charT c) {
            fwrite(&c, sizeof(charT), 1, f);
        }
        basic_fstream& seekg(size_t pos, ios::seekdir dir=ios::beg) {
            int whence;
            switch (dir) {
            case ios::beg:
                whence = SEEK_SET;
                break;
            case ios::end:
                whence = SEEK_END;
                break;
            case ios::cur:
                whence = SEEK_CUR;
                break;
            default:
                return *this;
            }
            fseek(f, pos, whence);
            return *this;
        }
        operator bool() {
            return good();
        }
        FILE* rdbuf() {
            return f;
        }
        basic_fstream& write(const charT* s, size_t count) {
            fwrite(s, sizeof(charT), count, f);
            return *this;
        }
        basic_fstream& operator<<(FILE* sb) {
            int c;
            while ((c = fgetc(sb)) != EOF) {
                put(c);
            }
            return *this;
        }
        basic_fstream& operator<<(const eastl::basic_string<charT> s) {
            fwrite(s.data(), sizeof(charT), s.length(), f);
            return *this;
        }
        basic_fstream& operator<<(const _precision_token t) {
            snprintf(fmt+1, sizeof(fmt)-2, "%d", t.digits);
            return *this;
        }
        basic_fstream& operator<<(double d) {
            size_t len = strlen(fmt);
            fmt[len] = 'f';
            fprintf(f, fmt, d);
            fmt[len] = '\0';
            return *this;
        }
        basic_fstream& operator>>(double& value) {
            fscanf(f, "%lf", &value);
            return *this;
        }
        basic_fstream& read(charT* s, size_t count) {
            fread(s, sizeof(charT), count, f);
            return *this;
        }
        void swap(basic_fstream& rhs) {
            eastl::swap(f, rhs.f);
        }
    protected:
        FILE* f;
        char fmt[16];
    };
    template <class charT>
    basic_fstream<charT>& operator<<(basic_fstream<charT>& fs, charT c) {
        fs.put(c);
        return fs;
    }
    template <class charT>
    basic_fstream<charT>& operator<<(basic_fstream<charT>& fs, const charT* s) {
        size_t len;
        for (len = 0; s[len] != 0; len++);
        return fs.write(s, len);
    }
    typedef basic_fstream<char> fstream;
    
    template <class charT>
    class basic_ofstream : public basic_fstream<charT> {
    public:
        basic_ofstream(const char* s) : basic_fstream<charT>(s) { }
        basic_ofstream(const char* s, ios::openmode mode) :
            basic_fstream<charT>(s, mode|ios::out) { }
        basic_ofstream(string s) : basic_ofstream(s.c_str()) {
        }
        virtual ~basic_ofstream() { }
        virtual void open(const char* s, ios::openmode mode) {
            basic_fstream<charT>::_open(s, mode|ios::out);
        }
    };
    typedef basic_ofstream<char> ofstream;
    
    template <class charT>
    class basic_ifstream : public basic_fstream<charT> {
    public:
        basic_ifstream(const char* s) : basic_fstream<charT>(s) { }
        basic_ifstream(const char* s, ios::openmode mode) :
            basic_fstream<charT>(s, mode|ios::in) { }
        basic_ifstream(string s) : basic_ifstream(s.c_str()) { }
        basic_ifstream(string s, ios::openmode mode) :
            basic_fstream<charT>(s.c_str(), mode|ios::in) { }
        virtual ~basic_ifstream() { }
        virtual void open(const char* s, ios::openmode mode) {
            basic_fstream<charT>::_open(s, mode|ios::in);
        }
    };
    typedef basic_ifstream<char> ifstream;
}

