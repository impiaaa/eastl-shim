#include <stdio.h>
#include <ios>
#include <EASTL/algorithm.h>

namespace std {
    template <class charT>
    class basic_fstream : public ios {
    public:
        basic_fstream() : f(NULL) { }
        basic_fstream(const char* s) : f(NULL) {
            open(s);
        }
        basic_fstream(const char* s, ios::openmode mode) : f(NULL) {
            open(s, mode);
        }
        virtual ~basic_fstream() {
            if (is_open()) {
                close();
            }
        }
        virtual void open(const char* s, ios::openmode mode) {
            _open(s, mode);
        };
        virtual void open(const char* s) {
            open(s, ios::binary);
        }
        virtual void open(const std::string s) {
            open(s.c_str(), ios::binary);
        }
        virtual void open(const std::string s, ios::openmode mode) {
            open(s.c_str(), mode);
        }
        virtual void _open(const char* s, ios::openmode mode) {
            char smode[4] = {0};
            if (mode&ios::app) {
                smode[0] = 'a';
                if (mode&ios::in) {
                    smode[1] = '+';
                }
            }
            else if (mode&ios::out) {
                smode[0] = 'w';
                if (mode&ios::in) {
                    smode[1] = '+';
                    if (!(mode&ios::trunc)) {
                        smode[0] = 'r';
                    }
                }
            }
            else if (mode&ios::in) {
                smode[0] = 'r';
            }
            if (mode&ios::binary) {
                if (smode[0] == '\0') {
                    smode[0] = 'b';
                }
                else if (smode[1] == '\0') {
                    smode[1] = 'b';
                }
                else if (smode[2] == '\0') {
                    smode[2] = 'b';
                }
            }
            f = fopen(s, smode);
            if (mode&ios::ate) {
                fseek(f, 0, SEEK_END);
            }
        }
        bool is_open() const {
            return f != NULL;
        }
        void close() {
            fclose(f);
            f = NULL;
        }
        long tellg() {
            return ftell(f);
        }
        bool good() {
            return is_open() && ferror(f) == 0;
        }
        bool fail() {
            return !good();
        }
        bool operator!() {
            return fail();
        }
        bool bad() {
            return !good();
        }
        bool eof() {
            return feof(f);
        }
        void clear() {
            clearerr(f);
        }
        void setstate(iostate state) {
            // TODO
        }
        void unget() {
            fseek(f, -1, SEEK_CUR);
        }
        charT peek() {
            charT c = get();
            unget();
            return c;
        }
        charT get() {
            return fgetc(f);
        }
        basic_fstream& seekg(size_t pos, ios::seekdir dir) {
            int whence;
            switch (dir) {
            case ios::beg:
                whence = SEEK_SET;
                break;
            case ios::end:
                whence = SEEK_END;
                break;
            case ios::cur:
                whence = SEEK_CUR;
                break;
            default:
                return *this;
            }
            fseek(f, pos, whence);
            return *this;
        }
        operator bool() {
            return good();
        }
        FILE* rdbuf() {
            return f;
        }
        basic_fstream& write(const charT* s, size_t count) {
            fwrite(s, sizeof(charT), count, f);
            return *this;
        }
        basic_fstream& operator<<( FILE* sb) {
            int c;
            while ((c = fgetc(sb)) != EOF) {
                fputc(c, f);
            }
            return *this;
        }
        basic_fstream& operator<<( const charT* s) {
            for (; *s != 0; s++) {
                fputc(*s, f);
            }
            return *this;
        }
        basic_fstream& operator<<( const std::string s) {
            return (*this)<<s.c_str();
        }
        basic_fstream& read(charT* s, size_t count) {
            fread(s, sizeof(charT), count, f);
            return *this;
        }
        void swap(basic_fstream& rhs) {
            eastl::swap(f, rhs.f);
        }
    protected:
        FILE* f;
    };
    typedef basic_fstream<char> fstream;
    
    template <class charT>
    class basic_ofstream : public basic_fstream<charT> {
    public:
        basic_ofstream(const char* s) : basic_fstream<charT>(s) { }
        basic_ofstream(const char* s, ios::openmode mode) :
            basic_fstream<charT>(s, mode|ios::out) { }
        basic_ofstream(string s) : basic_ofstream(s.c_str()) {
        }
        virtual ~basic_ofstream() { }
        virtual void open(const char* s, ios::openmode mode) {
            basic_fstream<charT>::_open(s, mode|ios::out);
        }
    };
    typedef basic_ofstream<char> ofstream;
    
    template <class charT>
    class basic_ifstream : public basic_fstream<charT> {
    public:
        basic_ifstream(const char* s) : basic_fstream<charT>(s) { }
        basic_ifstream(const char* s, ios::openmode mode) :
            basic_fstream<charT>(s, mode|ios::in) { }
        basic_ifstream(string s) : basic_ifstream(s.c_str()) { }
        basic_ifstream(string s, ios::openmode mode) :
            basic_fstream<charT>(s.c_str(), mode|ios::in) { }
        virtual ~basic_ifstream() { }
        virtual void open(const char* s, ios::openmode mode) {
            basic_fstream<charT>::_open(s, mode|ios::in);
        }
    };
    typedef basic_ifstream<char> ifstream;
}

